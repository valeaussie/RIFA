#define _USE_MATH_DEFINES
#include <random>
#include <iostream>
#include <vector>
#include <fstream>
#include <map>
#include <algorithm>
#include <math.h>

using namespace std;

void print_vector(vector < double > value);
double normalCDF(double value);
double num_offspring(double m0);

/* Simulate from the RIFA model and output the the observations. */

/*First invasion on Fisherman Island (Port of Brisbane)*/
//units of space in degrees and decimal minutes
//units of time in days
//latitude of the first nest
const float first_nest_x = -27.3541790;
//longitude of the first nest
const float first_nest_y = 153.1930033;
//time of founding of the first nest
const float first_nest_f = 0;
//time of first observation
const float first_observation = 2000;
//reproductive rate number of nests per month
const double rep_rate = 0.25;
double rep_rate_daily = rep_rate * 12 / 365;
//probability of a long jump (this value is a guess at the moment)
const double long_jump_rate = 0.1;
//parameter for the Levy distribution (this value is a guess at the moment)
const double Levy_param = 100;
//parameter for the exponential distribution for the short distance jumps (this value is a guess at the moment)
const double exp_jump_param = 1;
//maturation time for a nest in days (average 30.42 days in a month)
double matur_time = 8 * 30.42;


int firstGen() {
	random_device rd;
	mt19937 generator(rd());

	//generation of the first set of nests from the first invader before the first observation.
	//nests cannot produce new nests before they reache maturation (8 months).
	//these nests reproduce undisturbed until the time of first observation.

	//time from first founding to first observation
	float T0 = first_observation - (first_nest_f + matur_time);
	//first parameter of the Poisson distribution
	double m0 = rep_rate_daily * T0;

	//simulate the offspring generated by the first nest
	if (first_observation >= matur_time) {
		int num_offsp = num_offspring(m0);

		//simulate the time of founding of those nests
		uniform_real_distribution<double> unif(matur_time, first_observation);

		vector < double > vec_first_found;
		vector < double > vec_found;
		for (int i = 0; i < num_offsp; ++i) {
			double f = unif(generator);
			vec_first_found.push_back(f);
			vec_found.push_back(f);
		}

		//simulate number of long distance jumps
		int num_long_jump = 0;
		int num_short_jump = 0;

		binomial_distribution <> binom(num_offsp, long_jump_rate);
		num_long_jump = binom(generator);
		num_short_jump = num_offsp - num_long_jump;

		//simulate the angular direction of the jumps
		double theta = 0;

		uniform_real_distribution<double> unif_theta(0.0, 2 * M_PI);

		vector < double > vec_directions;
		for (int i = 0; i < num_offsp; ++i) {
			double f = unif_theta(generator);
			vec_directions.push_back(f);
		}

		vector < double > vec_jumps;
		//simulate the radial direction of the short jumps

		double short_rho = 0;

		exponential_distribution<> exp_jump(exp_jump_param);

		vector < double > vec_short_jumps;
		for (int i = 0; i < num_short_jump; ++i) {
			double f = exp_jump(generator);
			vec_short_jumps.push_back(f);
			vec_jumps.push_back(f);
		}

		//simulate the radial direction of the long jumps
		//there is no library for Levy distribution -> using inverse transform sampling

		double long_rho = 0;

		uniform_real_distribution<double> standardUnif(0.0, 1.0);

		vector < double > vec_long_jumps;
		for (int i = 0; i < num_long_jump; ++i) {
			double u = 1 - standardUnif(generator);
			double X = ((Levy_param) / ((1 / normalCDF(u)) * (1 / normalCDF(u))));
			vec_long_jumps.push_back(X);
			vec_jumps.push_back(X);
		}

		//define the cartesian coordinates of each new nest

		vector < double > vec_x;
		vector < double > vec_y;
		for (int i = 0; i < num_offsp; ++i) {
			double x = 0;
			double y = 0;
			x = first_nest_x + vec_jumps[i] * cos(vec_directions[i]);
			y = first_nest_y + vec_jumps[i] * sin(vec_directions[i]);
			vec_x.push_back(x);
			vec_y.push_back(y);
		}

		int num_new_offsp = num_offsp;

		//simulate all subsequent nests
		while (num_new_offsp > 0) {
			for (int i = 0; i < num_new_offsp; ++i) {
				//simulate the number of nests
				double m = rep_rate_daily * (first_observation - (vec_first_found[i] + matur_time));
				if (first_observation > (vec_first_found[i] + matur_time)) {
					poisson_distribution<int> pois(m);
					num_new_offsp = pois(generator);
					cout << "number of new offspring " << num_new_offsp << endl;
				}
				else { cout << "No nests can be created in such a short time" << m << endl; }

				//simulate the time of founding of the new nests
				if (first_observation > (vec_first_found[i] + matur_time)) {
					uniform_real_distribution<double> unif(matur_time + vec_first_found[i], first_observation);

					for (int j = 0; j < num_new_offsp; ++j) {
						double f = unif(generator);
						vec_found.push_back(f);
					}
				}

				
			}
		}

		cout << "offspring of first nest " << num_offsp << endl;
		cout << "vector of foundings " << endl;
		print_vector(vec_found);
		cout << "number of long jumps " << num_long_jump << endl;
		cout << "number of short jumps " << num_short_jump << endl;
		cout << "vector of theta " << endl;
		print_vector(vec_directions);
		cout << "vector of short jumps " << endl;
		print_vector(vec_short_jumps);
		cout << "vector of long jumps " << endl;
		print_vector(vec_long_jumps);
		cout << "x location of new nest " << endl;
		print_vector(vec_x);
		cout << "y location of new nest " << endl;
		print_vector(vec_y);
	}
	else { cout << "no nests can be created in such a short time" << endl; }



	return 0;
}

//F: prints a vector of doubles
void print_vector(vector < double > value) {
	for (const double x : value) cout << x << ' ';
	cout << endl;
}

//F: calculate the CDF of a standard normal distribution
double normalCDF(double value) {
	return 0.5 * erfc(-value * M_SQRT1_2);
}

//F: simulates the number of nests from a poisson distribution
double num_offspring(double m0) {
	random_device rd;
	mt19937 generator(rd());
	poisson_distribution<int> pois(m0);
	int num_offsp = pois(generator);
	if (num_offsp == 0) {
		num_offsp = 1;
	}
	return num_offsp;
}
